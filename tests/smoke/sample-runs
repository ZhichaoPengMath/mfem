#!/bin/sh

# Copyright (c) 2010, Lawrence Livermore National Security, LLC. Produced at the
# Lawrence Livermore National Laboratory. LLNL-CODE-443211. All Rights reserved.
# See file COPYRIGHT for details.
#
# This file is part of the MFEM library. For more information and source code
# availability see http://mfem.googlecode.com.
#
# MFEM is free software; you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License (as published by the Free
# Software Foundation) version 2.1 dated February 1999.

make="${MAKE:-make}"
run_prefix=""
run_vg="valgrind --leak-check=full --show-reachable=yes --track-origins=yes"
run_suffix="-no-vis"
skip_gen_meshes="yes"
cur_dir="${PWD}"
mfem_dir="../.."
# The group format is: '"group-name" "group-summary-title" "group-directory"
# "group-source-patterns"'
groups_serial=(
'"examples"
   "Examples:"
   "examples"
   "ex{,1}[0-9].cpp"'
#   "ex1.cpp"'
# '"sundials examples"
#    "SUNDIALS examples:"
#    "examples/sundials"
#    "ex{9,10}.cpp"'
'"performance"
   "Performance miniapps:"
   "miniapps/performance"
   "ex1.cpp"'
#   ""'
'"meshing"
   "Meshing miniapps:"
   "miniapps/meshing"
   "mobius-strip.cpp klein-bottle.cpp mesh-optimizer.cpp"'
)
# Parallel groups
groups_parallel=(
'"examples"
   "Examples:"
   "examples"
   "ex{,1}[0-9]p.cpp"'
#   "ex1p.cpp"'
# '"sundials examples"
#    "SUNDIALS examples:"
#    "examples/sundials"
#    "ex{9,10}p.cpp"'
'"performance"
   "Performance miniapps:"
   "miniapps/performance"
   "ex1p.cpp"'
#   ""'
'"meshing"
   "Meshing miniapps:"
   "miniapps/meshing"
   "pmesh-optimizer.cpp"'
'"electromagnetics"
   "Electromagnetics miniapps:"
   "miniapps/electromagnetics"
   "joule.cpp"'
#   "{volta,tesla,joule}.cpp"' # todo: multiline sample runs
)
make_all="all"
make_params=""
base_timeformat=$'real: %3Rs  user: %3Us  sys: %3Ss  %%cpu: %P'
# separator
sep='----------------------------------------------------------------'

# Command line parameters:
make_lib="serial"
run_group="serial"
groups=("${groups_serial[@]}")
valgrind="no"
make_j="-j"
color="no"
built="no"
timing="no"

# Read the sample runs from the source "$1" and put them in the array variable
# "runs".
function extract_sample_runs()
{
   local old_IFS="${IFS}"
   local src="$1"
   if [ "${src}" == "" ]; then runs=(); return 1; fi
   local app=${src%.cpp}
   local vg_app="${app}"
   if [ "${valgrind}" == "yes" ]; then vg_app="${run_vg} ${app}"; fi
   if [ "${run_group}" == "serial" ]; then
      # sample runs are lines matching "^//.*  ${app}" with everything in front
      # of "${app}" removed:
      runs=`grep "^//.*  ${app}" "${src}" |
            sed -e "s/.*  ${app}/${vg_app}/g"`
   else
      # sample runs are lines matching "^//.*  mpirun .* ${app}" with everything
      # in front of "mpirun" removed:
      runs=`grep "^//.*  mpirun .* ${app}" "${src}" |
            sed -e "s/.*  mpirun \(.*\) ${app}/mpirun \1 ${vg_app}/g"`
   fi
   if [ "$skip_gen_meshes" == "yes" ]; then
      runs=`printf "%s" "$runs" | grep -v ".* -m .*\.gen"`
   fi
   IFS=$'\n'
   runs=(${runs})
   IFS="${old_IFS}"
}

# Process command line parameters
while [ $# -gt 0 ]; do

case "$1" in
   -h|-help)
      # Echo usage information
      cat <<EOF

   $0 [options]

   Options:
      -h|-help    print this usage information and exit
      -p|-par     build and run the parallel sample runs
      -q          build parallel library, run the serial examples
      -g <dir> <pattern>
                  specify explicitly a group (dir + file pattern) to run
      -v          enable valgrind
      -j <np>     specify the number of processors to use for building
      -c|-color   always use colors for the OK/FAILED status messages
      -b|-built   do NOT rebuild the library and the executables
      -t|-time    measure and print execution time for each sample run
      -s|-show    show all configured sample runs and exit; use after <mfem_dir>
      -n          dry run: replace "\$sample_run" with "echo \$sample_run"
       *          any other parameter is treated as <mfem_dir>
      <mfem_dir>  is the MFEM source directory; current value: ${mfem_dir}

   This script tests all the sample runs listed in the begining comments of
   MFEM's serial or parallel example and miniapp codes. The list of sample runs
   is auto-generated and can be viewed with the -s|-show option.

   Example usage: $0 ../..

EOF
      exit
      ;;
   -p|-parallel)
      make_lib="parallel"
      run_group="parallel"
      groups=("${groups_parallel[@]}")
      ;;
   -q)
      make_lib="parallel"
      run_group="serial"
      groups=("${groups_serial[@]}")
      ;;
   -g)
      test_group='"test group" "Test group:" "'"$2"'" "'"$3"'"'
      groups=("${test_group}")
      shift 2
      ;;
   -v)
      valgrind="yes"
      ;;
   -j)
      shift
      make_j="-j $1"
      ;;
   -c|-color)
      color="yes"
      ;;
   -b|-built)
      built="yes"
      ;;
   -t|-time)
      timing="yes"
      ;;
   -s|-show)
      echo "${sep}"
      for group_params in "${groups[@]}"; do
         eval params=(${group_params})
         name="${params[0]}"
         title="${params[1]}"
         group_dir="${mfem_dir}/${params[2]}"
         pattern="${params[3]}"
         printf "group name:    [%s]\n" "${name}"
         printf "summary title: [%s]\n" "${title}"
         printf "directory:     [%s]\n" "${group_dir}"
         printf "pattern:       [%s]\n" "${pattern}"
         cd "${cur_dir}"; cd "${group_dir}" || exit 1
         eval sources=(${pattern})
         printf "sources:       (%s)\n" "${sources[*]}"
         printf "sample runs:\n"
         for src in "${sources[@]}"; do
            extract_sample_runs "${src}"
            for run in "${runs[@]}"; do
               printf "   %s\n" "${run}"
            done
         done
         echo "${sep}"
      done
      exit
      ;;
   -n)
      run_prefix="echo"
      ;;
   *)
      mfem_dir="$1"
      ;;
esac

shift
done # while ...

# Setup colors
if [ -t 1 ] || [ "${color}" == "yes" ]; then
   red='\033[0;31m'
   green='\033[0;32m'
   none='\033[0m'
else
   red=
   green=
   none=
fi

# Run the given command, saving the rune time in the variable "timer".
timed_run()
{
   timer="$({ time "$@" 1>&3 2>&4; } 2>&1)"
} 3>&1 4>&2

# This function is used to execute the sample runs
function go()
{
   local cmd=("$@")
   local res=""
   echo $sep
   echo "<${group}>" "${cmd[@]}"
   echo $sep
   if [ "${timing}" == "yes" ]; then
      timed_run "${cmd[@]}"
   else
      "${cmd[@]}"
   fi
   if [ "$?" -eq 0 ]; then
      res="${green}  OK  ${none}"
   else
      res="${red}FAILED${none}"
   fi
   printf "[${res}] <${group}> ${cmd[*]}\n"
   if [ "${timing}" == "yes" ]; then
      printf "Run time: %s\n" "${timer}"
      timer=(${timer})
      timer="${timer[1]}"
      printf -v line "[$res](%8s) ${cmd[*]}" "$timer"
      summary=("${summary[@]}" "$line")
   else
      summary=("${summary[@]}" "[${res}] ${cmd[*]}")
   fi
   echo $sep
}

# This function is used to run a group of sample runs (in the same directory)
function go_group()
{
   if [ $# -eq 0 ]; then return 0; fi
   for src in "$@"; do
      extract_sample_runs "${src}" || continue
      for run in "${runs[@]}"; do
         if [ "${run}" == "" ]; then continue; fi
         go ${run_prefix} ${run} ${run_suffix}
      done
   done
   ${make} clean-exec
}


# Make sure $mfem_dir exists and we can cd into it
cd "$mfem_dir" || exit 1
# Make $mfem_dir is an absolute path
mfem_dir="$PWD"
TIMEFORMAT="${base_timeformat}"

# Echo the given command line; then run it writing output to $echo_run_out (if non-empty)
# or /dev/null
function echo_run()
{
   echo "   $@"
   "$@" > "${echo_run_out:-/dev/null}" 2>&1
}

# Function that builds the mfem library, examples and miniapps
function build_all()
{
   cd "${mfem_dir}"
   printf "Building all examples and miniapps:\n"
   local echo_run_out="${cur_dir}/sample-runs-build.log"
   echo_run ${make} distclean && \
   echo_run ${make} ${make_lib} ${make_params} ${make_j} && \
   echo_run ${make} ${make_all} ${make_j}
   local build_status="$?"
   if [ "$build_status" -ne 0 ]; then
      echo
      echo "Building failed! Failed build step output:"
      echo "$sep"
      cat "$echo_run_out"
      echo "$sep"
      echo
   fi
   rm -f "$echo_run_out"
   return "$build_status"
}

# Build all mfem examples and miniapps
if [ "${built}" == "no" ]; then
   if [ "${timing}" == "yes" ]; then
      timed_run build_all || exit 1
      printf "Build time: %s\n" "${timer}"
   else
      build_all || exit 1
   fi
fi

summary=()
PATH=.:$PATH
cd "${mfem_dir}"
echo "$sep"
echo "MFEM configuration"
echo "$sep"
${make} info
echo "$sep"

# Function that runs all sample runs, given by the array variable "groups".
function all_go()
{
   for group_params in "${groups[@]}"; do
      eval params=(${group_params})
      group="${params[0]}"
      cd "${mfem_dir}/${params[2]}" || exit 1
      eval sources=(${params[3]})
      summary=("${summary[@]}" "${params[1]}")
      go_group "${sources[@]}"
   done

   printf "Summary:\n--------\n"
   for line in "${summary[@]}"; do
      printf "${line}\n"
   done
}

# Run all sample runs.
if [ "${timing}" == "yes" ]; then
   timed_run all_go
   printf "Total run time: %s\n" "${timer}"
else
   all_go
fi
echo
